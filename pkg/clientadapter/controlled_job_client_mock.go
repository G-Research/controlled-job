// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package clientadapter

import (
	"context"
	batch "github.com/G-Research/controlled-job/api/v1"
	kbatch "k8s.io/api/batch/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sync"
)

// Ensure, that ControlledJobClientMock does implement ControlledJobClient.
// If this is not the case, regenerate this file with moq.
var _ ControlledJobClient = &ControlledJobClientMock{}

// ControlledJobClientMock is a mock implementation of ControlledJobClient.
//
//	func TestSomethingThatUsesControlledJobClient(t *testing.T) {
//
//		// make and configure a mocked ControlledJobClient
//		mockedControlledJobClient := &ControlledJobClientMock{
//			CreateJobFunc: func(ctx context.Context, job *kbatch.Job) error {
//				panic("mock out the CreateJob method")
//			},
//			DeleteJobFunc: func(ctx context.Context, job *kbatch.Job, propagation metav1.DeletionPropagation) error {
//				panic("mock out the DeleteJob method")
//			},
//			GetControlledJobFunc: func(ctx context.Context, namespacedName types.NamespacedName) (*batch.ControlledJob, bool, error) {
//				panic("mock out the GetControlledJob method")
//			},
//			ListJobsForControlledJobFunc: func(ctx context.Context, namespacedName types.NamespacedName) (kbatch.JobList, error) {
//				panic("mock out the ListJobsForControlledJob method")
//			},
//			SuspendJobFunc: func(ctx context.Context, job *kbatch.Job) error {
//				panic("mock out the SuspendJob method")
//			},
//			UnsuspendJobFunc: func(ctx context.Context, job *kbatch.Job) error {
//				panic("mock out the UnsuspendJob method")
//			},
//			UpdateControlledJobFunc: func(ctx context.Context, controlledJob *batch.ControlledJob) error {
//				panic("mock out the UpdateControlledJob method")
//			},
//			UpdateStatusFunc: func(ctx context.Context, controlledJob *batch.ControlledJob) error {
//				panic("mock out the UpdateStatus method")
//			},
//		}
//
//		// use mockedControlledJobClient in code that requires ControlledJobClient
//		// and then make assertions.
//
//	}
type ControlledJobClientMock struct {
	// CreateJobFunc mocks the CreateJob method.
	CreateJobFunc func(ctx context.Context, job *kbatch.Job) error

	// DeleteJobFunc mocks the DeleteJob method.
	DeleteJobFunc func(ctx context.Context, job *kbatch.Job, propagation metav1.DeletionPropagation) error

	// GetControlledJobFunc mocks the GetControlledJob method.
	GetControlledJobFunc func(ctx context.Context, namespacedName types.NamespacedName) (*batch.ControlledJob, bool, error)

	// ListJobsForControlledJobFunc mocks the ListJobsForControlledJob method.
	ListJobsForControlledJobFunc func(ctx context.Context, namespacedName types.NamespacedName) (kbatch.JobList, error)

	// SuspendJobFunc mocks the SuspendJob method.
	SuspendJobFunc func(ctx context.Context, job *kbatch.Job) error

	// UnsuspendJobFunc mocks the UnsuspendJob method.
	UnsuspendJobFunc func(ctx context.Context, job *kbatch.Job) error

	// UpdateControlledJobFunc mocks the UpdateControlledJob method.
	UpdateControlledJobFunc func(ctx context.Context, controlledJob *batch.ControlledJob) error

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(ctx context.Context, controlledJob *batch.ControlledJob) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateJob holds details about calls to the CreateJob method.
		CreateJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Job is the job argument value.
			Job *kbatch.Job
		}
		// DeleteJob holds details about calls to the DeleteJob method.
		DeleteJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Job is the job argument value.
			Job *kbatch.Job
			// Propagation is the propagation argument value.
			Propagation metav1.DeletionPropagation
		}
		// GetControlledJob holds details about calls to the GetControlledJob method.
		GetControlledJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespacedName is the namespacedName argument value.
			NamespacedName types.NamespacedName
		}
		// ListJobsForControlledJob holds details about calls to the ListJobsForControlledJob method.
		ListJobsForControlledJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespacedName is the namespacedName argument value.
			NamespacedName types.NamespacedName
		}
		// SuspendJob holds details about calls to the SuspendJob method.
		SuspendJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Job is the job argument value.
			Job *kbatch.Job
		}
		// UnsuspendJob holds details about calls to the UnsuspendJob method.
		UnsuspendJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Job is the job argument value.
			Job *kbatch.Job
		}
		// UpdateControlledJob holds details about calls to the UpdateControlledJob method.
		UpdateControlledJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ControlledJob is the controlledJob argument value.
			ControlledJob *batch.ControlledJob
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ControlledJob is the controlledJob argument value.
			ControlledJob *batch.ControlledJob
		}
	}
	lockCreateJob                sync.RWMutex
	lockDeleteJob                sync.RWMutex
	lockGetControlledJob         sync.RWMutex
	lockListJobsForControlledJob sync.RWMutex
	lockSuspendJob               sync.RWMutex
	lockUnsuspendJob             sync.RWMutex
	lockUpdateControlledJob      sync.RWMutex
	lockUpdateStatus             sync.RWMutex
}

// CreateJob calls CreateJobFunc.
func (mock *ControlledJobClientMock) CreateJob(ctx context.Context, job *kbatch.Job) error {
	if mock.CreateJobFunc == nil {
		panic("ControlledJobClientMock.CreateJobFunc: method is nil but ControlledJobClient.CreateJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Job *kbatch.Job
	}{
		Ctx: ctx,
		Job: job,
	}
	mock.lockCreateJob.Lock()
	mock.calls.CreateJob = append(mock.calls.CreateJob, callInfo)
	mock.lockCreateJob.Unlock()
	return mock.CreateJobFunc(ctx, job)
}

// CreateJobCalls gets all the calls that were made to CreateJob.
// Check the length with:
//
//	len(mockedControlledJobClient.CreateJobCalls())
func (mock *ControlledJobClientMock) CreateJobCalls() []struct {
	Ctx context.Context
	Job *kbatch.Job
} {
	var calls []struct {
		Ctx context.Context
		Job *kbatch.Job
	}
	mock.lockCreateJob.RLock()
	calls = mock.calls.CreateJob
	mock.lockCreateJob.RUnlock()
	return calls
}

// DeleteJob calls DeleteJobFunc.
func (mock *ControlledJobClientMock) DeleteJob(ctx context.Context, job *kbatch.Job, propagation metav1.DeletionPropagation) error {
	if mock.DeleteJobFunc == nil {
		panic("ControlledJobClientMock.DeleteJobFunc: method is nil but ControlledJobClient.DeleteJob was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Job         *kbatch.Job
		Propagation metav1.DeletionPropagation
	}{
		Ctx:         ctx,
		Job:         job,
		Propagation: propagation,
	}
	mock.lockDeleteJob.Lock()
	mock.calls.DeleteJob = append(mock.calls.DeleteJob, callInfo)
	mock.lockDeleteJob.Unlock()
	return mock.DeleteJobFunc(ctx, job, propagation)
}

// DeleteJobCalls gets all the calls that were made to DeleteJob.
// Check the length with:
//
//	len(mockedControlledJobClient.DeleteJobCalls())
func (mock *ControlledJobClientMock) DeleteJobCalls() []struct {
	Ctx         context.Context
	Job         *kbatch.Job
	Propagation metav1.DeletionPropagation
} {
	var calls []struct {
		Ctx         context.Context
		Job         *kbatch.Job
		Propagation metav1.DeletionPropagation
	}
	mock.lockDeleteJob.RLock()
	calls = mock.calls.DeleteJob
	mock.lockDeleteJob.RUnlock()
	return calls
}

// GetControlledJob calls GetControlledJobFunc.
func (mock *ControlledJobClientMock) GetControlledJob(ctx context.Context, namespacedName types.NamespacedName) (*batch.ControlledJob, bool, error) {
	if mock.GetControlledJobFunc == nil {
		panic("ControlledJobClientMock.GetControlledJobFunc: method is nil but ControlledJobClient.GetControlledJob was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		NamespacedName types.NamespacedName
	}{
		Ctx:            ctx,
		NamespacedName: namespacedName,
	}
	mock.lockGetControlledJob.Lock()
	mock.calls.GetControlledJob = append(mock.calls.GetControlledJob, callInfo)
	mock.lockGetControlledJob.Unlock()
	return mock.GetControlledJobFunc(ctx, namespacedName)
}

// GetControlledJobCalls gets all the calls that were made to GetControlledJob.
// Check the length with:
//
//	len(mockedControlledJobClient.GetControlledJobCalls())
func (mock *ControlledJobClientMock) GetControlledJobCalls() []struct {
	Ctx            context.Context
	NamespacedName types.NamespacedName
} {
	var calls []struct {
		Ctx            context.Context
		NamespacedName types.NamespacedName
	}
	mock.lockGetControlledJob.RLock()
	calls = mock.calls.GetControlledJob
	mock.lockGetControlledJob.RUnlock()
	return calls
}

// ListJobsForControlledJob calls ListJobsForControlledJobFunc.
func (mock *ControlledJobClientMock) ListJobsForControlledJob(ctx context.Context, namespacedName types.NamespacedName) (kbatch.JobList, error) {
	if mock.ListJobsForControlledJobFunc == nil {
		panic("ControlledJobClientMock.ListJobsForControlledJobFunc: method is nil but ControlledJobClient.ListJobsForControlledJob was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		NamespacedName types.NamespacedName
	}{
		Ctx:            ctx,
		NamespacedName: namespacedName,
	}
	mock.lockListJobsForControlledJob.Lock()
	mock.calls.ListJobsForControlledJob = append(mock.calls.ListJobsForControlledJob, callInfo)
	mock.lockListJobsForControlledJob.Unlock()
	return mock.ListJobsForControlledJobFunc(ctx, namespacedName)
}

// ListJobsForControlledJobCalls gets all the calls that were made to ListJobsForControlledJob.
// Check the length with:
//
//	len(mockedControlledJobClient.ListJobsForControlledJobCalls())
func (mock *ControlledJobClientMock) ListJobsForControlledJobCalls() []struct {
	Ctx            context.Context
	NamespacedName types.NamespacedName
} {
	var calls []struct {
		Ctx            context.Context
		NamespacedName types.NamespacedName
	}
	mock.lockListJobsForControlledJob.RLock()
	calls = mock.calls.ListJobsForControlledJob
	mock.lockListJobsForControlledJob.RUnlock()
	return calls
}

// SuspendJob calls SuspendJobFunc.
func (mock *ControlledJobClientMock) SuspendJob(ctx context.Context, job *kbatch.Job) error {
	if mock.SuspendJobFunc == nil {
		panic("ControlledJobClientMock.SuspendJobFunc: method is nil but ControlledJobClient.SuspendJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Job *kbatch.Job
	}{
		Ctx: ctx,
		Job: job,
	}
	mock.lockSuspendJob.Lock()
	mock.calls.SuspendJob = append(mock.calls.SuspendJob, callInfo)
	mock.lockSuspendJob.Unlock()
	return mock.SuspendJobFunc(ctx, job)
}

// SuspendJobCalls gets all the calls that were made to SuspendJob.
// Check the length with:
//
//	len(mockedControlledJobClient.SuspendJobCalls())
func (mock *ControlledJobClientMock) SuspendJobCalls() []struct {
	Ctx context.Context
	Job *kbatch.Job
} {
	var calls []struct {
		Ctx context.Context
		Job *kbatch.Job
	}
	mock.lockSuspendJob.RLock()
	calls = mock.calls.SuspendJob
	mock.lockSuspendJob.RUnlock()
	return calls
}

// UnsuspendJob calls UnsuspendJobFunc.
func (mock *ControlledJobClientMock) UnsuspendJob(ctx context.Context, job *kbatch.Job) error {
	if mock.UnsuspendJobFunc == nil {
		panic("ControlledJobClientMock.UnsuspendJobFunc: method is nil but ControlledJobClient.UnsuspendJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Job *kbatch.Job
	}{
		Ctx: ctx,
		Job: job,
	}
	mock.lockUnsuspendJob.Lock()
	mock.calls.UnsuspendJob = append(mock.calls.UnsuspendJob, callInfo)
	mock.lockUnsuspendJob.Unlock()
	return mock.UnsuspendJobFunc(ctx, job)
}

// UnsuspendJobCalls gets all the calls that were made to UnsuspendJob.
// Check the length with:
//
//	len(mockedControlledJobClient.UnsuspendJobCalls())
func (mock *ControlledJobClientMock) UnsuspendJobCalls() []struct {
	Ctx context.Context
	Job *kbatch.Job
} {
	var calls []struct {
		Ctx context.Context
		Job *kbatch.Job
	}
	mock.lockUnsuspendJob.RLock()
	calls = mock.calls.UnsuspendJob
	mock.lockUnsuspendJob.RUnlock()
	return calls
}

// UpdateControlledJob calls UpdateControlledJobFunc.
func (mock *ControlledJobClientMock) UpdateControlledJob(ctx context.Context, controlledJob *batch.ControlledJob) error {
	if mock.UpdateControlledJobFunc == nil {
		panic("ControlledJobClientMock.UpdateControlledJobFunc: method is nil but ControlledJobClient.UpdateControlledJob was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ControlledJob *batch.ControlledJob
	}{
		Ctx:           ctx,
		ControlledJob: controlledJob,
	}
	mock.lockUpdateControlledJob.Lock()
	mock.calls.UpdateControlledJob = append(mock.calls.UpdateControlledJob, callInfo)
	mock.lockUpdateControlledJob.Unlock()
	return mock.UpdateControlledJobFunc(ctx, controlledJob)
}

// UpdateControlledJobCalls gets all the calls that were made to UpdateControlledJob.
// Check the length with:
//
//	len(mockedControlledJobClient.UpdateControlledJobCalls())
func (mock *ControlledJobClientMock) UpdateControlledJobCalls() []struct {
	Ctx           context.Context
	ControlledJob *batch.ControlledJob
} {
	var calls []struct {
		Ctx           context.Context
		ControlledJob *batch.ControlledJob
	}
	mock.lockUpdateControlledJob.RLock()
	calls = mock.calls.UpdateControlledJob
	mock.lockUpdateControlledJob.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *ControlledJobClientMock) UpdateStatus(ctx context.Context, controlledJob *batch.ControlledJob) error {
	if mock.UpdateStatusFunc == nil {
		panic("ControlledJobClientMock.UpdateStatusFunc: method is nil but ControlledJobClient.UpdateStatus was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ControlledJob *batch.ControlledJob
	}{
		Ctx:           ctx,
		ControlledJob: controlledJob,
	}
	mock.lockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	mock.lockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(ctx, controlledJob)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//
//	len(mockedControlledJobClient.UpdateStatusCalls())
func (mock *ControlledJobClientMock) UpdateStatusCalls() []struct {
	Ctx           context.Context
	ControlledJob *batch.ControlledJob
} {
	var calls []struct {
		Ctx           context.Context
		ControlledJob *batch.ControlledJob
	}
	mock.lockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	mock.lockUpdateStatus.RUnlock()
	return calls
}
